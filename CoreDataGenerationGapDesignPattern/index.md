---
layout: page
title: CoreDataGenerationGapDesignPattern
---



I have a Core Data model from which I generate custom classes all of them inheriting from NSManagedObject. That is all fine. But when I want to add custom code to the classes it becomes a mess when I regenerate the code from the data model, because then I have to merge the changes manually.

I would much rather use the "Generation Gap" design pattern, where I put my custom code in a class that extends the generated class. But I can't seem to figure out how to do that with the xcode tools. 

Do you guys know of a best practice way of doing this.

Ps. I already had a brief look at "mogenerator". Is that the only way to do what I want?

----

Uhm, isn't mogenerator the *only* Core Data code generator out there, for now? I mean, Xcode never generates *any* code for you; it compiles your entity model into an efficient representation which Core Data loads at runtime, but no code is ever generated (if you do [someObject class] you'll see it is equa to NSManagedObject).

Since Xcode does not generate any code, there is no need for a generation gap (which is useful only when code generation would otherwise wipe out your customizations). If you don't want to use mogenerator, simply make a new class and set it as the class for your entity in the editor; Xcode will not modify it. -- EmanueleVulcano aka millenomi

----
Xcode certainly does have a Core Data code generator. In your model you click File -> New File and select "Managed Object Class". I opens the "Managed Object Class Generation" utility. Which lets you select from which entities in your model you would like to generate classes.

So - my question remains :-)

----
I put my code in categories of the X Code generated Core Data classes.  For example if there is a class, VTPath, that is an X Code generated subclass of NSManagedObject

I simply define VTPath+Utility.m  and VTPath+Quartz.m and so forth:

[VTPath+Utility.m]
    
#import "VTPath.h"

@implementation VTPath (Utility)

- (NSBezierPath *)bezierPathRepresentation;
{
   ...
}

@end


[VTPath+Quartz.m]
    
@implementation VTPath (Quartz)

- (void)strokePath
{
   ...
}

@end


The separate categoy implementation files are never overwritten when the Core Data classes are regenerated by X Code.
The one big limitation of this approach is that I can't easily add instance variables to the Core Data classes.  I usually solve that problem by providing at least one transient attribute in the model entities.  I then hyjack the transient attribute for whatever devious needs I may have in the categories.

Alternatively, you can always simulate instance variables in a category: <http://www.cocoabuilder.com/archive/message/cocoa/2004/12/4/123013>

